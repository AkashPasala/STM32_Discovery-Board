/* STM32F407 TIM2 scheduler example (bare-metal)
   Keil uVision5
   Uses TIM2 interrupt every 1 second to alternate LED blink modes.
   PD12..PD15 blink in sync.
*/

#include "stm32f4xx.h"   // CMSIS device header

/* Global millisecond counter (incremented by SysTick) */
volatile uint32_t msTicks = 0;

/* Mode toggle variable: 0 -> slow, 1 -> fast */
volatile uint8_t sched_mode = 0;

/* Forward declarations */
void delay_ms(uint32_t ms);
void LEDs_on(void);
void LEDs_off(void);
void blink_mode(uint32_t on_ms, uint32_t off_ms, uint32_t repeats);
void GPIO_Init_PD12_15(void);
void TIM2_Init_1Hz(void);
void SysTick_Init_1ms(void);

/* SysTick handler increments ms counter */
void SysTick_Handler(void) {
    msTicks++;
}

/* Simple millisecond delay using SysTick */
void delay_ms(uint32_t ms) {
    uint32_t target = msTicks + ms;
    while(msTicks < target) { __NOP(); }
}

/* Turn on PD12..PD15 */
void LEDs_on(void) {
    GPIOD->BSRR = (1U<<12) | (1U<<13) | (1U<<14) | (1U<<15);
}

/* Turn off PD12..PD15 */
void LEDs_off(void) {
    GPIOD->BSRR = ((1U<<12) | (1U<<13) | (1U<<14) | (1U<<15)) << 16; // reset bits
}

/* Blink all 4 LEDs repeats times with on_ms and off_ms delays */
void blink_mode(uint32_t on_ms, uint32_t off_ms, uint32_t repeats) {
    for(uint32_t i=0; i<repeats; ++i) {
        LEDs_on();
        delay_ms(on_ms);
        LEDs_off();
        delay_ms(off_ms);
    }
}

/* Initialize GPIOD pins 12..15 as general purpose outputs */
void GPIO_Init_PD12_15(void) {
    /* Enable GPIOD clock */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;
    /* Small delay to let clock start */
    volatile uint32_t tmp = RCC->AHB1ENR;
    (void)tmp;

    /* Set PD12..PD15 to output (MODER = 01) */
    GPIOD->MODER &= ~(
        (3U << (12*2)) |
        (3U << (13*2)) |
        (3U << (14*2)) |
        (3U << (15*2))
    );
    GPIOD->MODER |= (
        (1U << (12*2)) |
        (1U << (13*2)) |
        (1U << (14*2)) |
        (1U << (15*2))
    );

    /* Set output type push-pull (default 0) and speed (optional) */
    GPIOD->OTYPER &= ~(
        (1U<<12) | (1U<<13) | (1U<<14) | (1U<<15)
    );
    GPIOD->OSPEEDR |= (
        (2U << (12*2)) |
        (2U << (13*2)) |
        (2U << (14*2)) |
        (2U << (15*2))
    );
    /* No pull-up/pull-down */
    GPIOD->PUPDR &= ~(
        (3U << (12*2)) |
        (3U << (13*2)) |
        (3U << (14*2)) |
        (3U << (15*2))
    );
}

/* TIM2 init to generate update event at 1 Hz.
   Assumes TIM2 clock = 84 MHz. Adjust PSC/ARR if your timer clock differs.
*/
void TIM2_Init_1Hz(void) {
    /* Enable TIM2 clock (APB1) */
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
    volatile uint32_t tmp = RCC->APB1ENR; (void)tmp;

    /* Disable timer while configuring */
    TIM2->CR1 = 0;

    /* PSC and ARR values for 1 Hz from 84 MHz timer clock:
       PSC = 8399 -> divides by 8400
       ARR = 9999 -> further divides by 10000
       Result: 84,000,000 / 8400 / 10000 = 1 Hz
    */
    TIM2->PSC = 8399U;
    TIM2->ARR = 9999U;

    /* Clear update flag */
    TIM2->SR = 0;

    /* Enable update interrupt */
    TIM2->DIER |= TIM_DIER_UIE;

    /* Enable TIM2 IRQ in NVIC with priority */
    NVIC_SetPriority(TIM2_IRQn, 2);
    NVIC_EnableIRQ(TIM2_IRQn);

    /* Enable timer */
    TIM2->CR1 |= TIM_CR1_CEN;
}

/* TIM2 IRQ handler: scheduler + run blink sequence inline */
void TIM2_IRQHandler(void) {
    /* Check update interrupt flag */
    if (TIM2->SR & TIM_SR_UIF) {
        /* Clear UIF */
        TIM2->SR &= ~TIM_SR_UIF;

        /* Scheduler: select mode based on toggling sched_mode
           On first call sched_mode==0 -> slow mode (200ms on/off, 2 repeats)
           On second call sched_mode==1 -> fast mode (100ms on/off, 2 repeats)
        */
        if (sched_mode == 0) {
            /* Slow mode: two blinks with 200ms on / 200ms off each */
            blink_mode(200, 200, 2);
            sched_mode = 1; /* next time: fast */
        } else {
            /* Fast mode: two blinks with 100ms on / 100ms off each */
            blink_mode(100, 100, 2);
            sched_mode = 0; /* next time: slow */
        }
    }
}

/* Initialize SysTick for 1 ms ticks based on SystemCoreClock */
void SysTick_Init_1ms(void) {
    /* SysTick_Config uses SystemCoreClock CMSIS variable.
       It sets reload = SystemCoreClock/1000 - 1 to get 1ms tick.
    */
    if (SysTick_Config(SystemCoreClock / 1000U) != 0) {
        /* Handle error - infinite loop */
        while (1) { __NOP(); }
    }
    /* Optionally set SysTick IRQ priority */
    NVIC_SetPriority(SysTick_IRQn, 1);
}

/* main */
int main(void) {
    /* SystemInit() is called before main in startup (sets up clocks and SystemCoreClock).
       If your project doesn't call SystemInit(), ensure SystemCoreClock is set appropriately.
    */

    /* Initialize SysTick early for reliable ms delays */
    SysTick_Init_1ms();

    /* Initialize LEDs */
    GPIO_Init_PD12_15();
    LEDs_off();

    /* Initialize TIM2 to 1 Hz */
    TIM2_Init_1Hz();

    /* Main loop can be empty; work happens in TIM2 IRQ handler */
    while (1) {
        __WFI(); /* wait for interrupt - low power */
    }
}
