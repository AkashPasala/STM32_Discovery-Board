/* STM32F407 TIM2 scheduler example (bare-metal) with EXTI0 emergency button
   Keil uVision5
   - TIM2 generates 1 Hz update interrupt (scheduler)
   - EXTI0 (PA0 user button) toggles emergency mode (1s blink) on/off
   - EXTI0 priority = 0 (highest), TIM2 priority = 1
   - A simple mutex (led_mutex) protects LEDs so scheduler can't be interrupted
     by EXTI0 while it is executing. TIM2 disables EXTI0 during its critical section.
   - When emergency_mode is active TIM2 IRQ is disabled and main loop blinks LEDs.
*/

#include "stm32f4xx.h"   // CMSIS device header

/* Global millisecond counter (incremented by SysTick) */
volatile uint32_t msTicks = 0;

/* Mode toggle variable: 0 -> slow, 1 -> fast (used by TIM2 scheduler) */
volatile uint8_t sched_mode = 0;

/* Emergency mode flag (toggled by EXTI0) */
volatile uint8_t emergency_mode = 0;

/* Simple mutex for LED resource: 0 -> free, 1 -> locked */
volatile uint8_t led_mutex = 0;

/* Forward declarations */
void delay_ms(uint32_t ms);
void LEDs_on(void);
void LEDs_off(void);
void blink_mode(uint32_t on_ms, uint32_t off_ms, uint32_t repeats);
void GPIO_Init_PD12_15(void);
void TIM2_Init_1Hz(void);
void SysTick_Init_1ms(void);
void EXTI0_Init_PA0(void);

/* SysTick handler increments ms counter */
void SysTick_Handler(void) {
    msTicks++;
}

/* Simple millisecond delay using SysTick */
void delay_ms(uint32_t ms) {
    uint32_t target = msTicks + ms;
    while(msTicks < target) { __NOP(); }
}

/* Turn on PD12..PD15 */
void LEDs_on(void) {
    GPIOD->BSRR = (1U<<12) | (1U<<13) | (1U<<14) | (1U<<15);
}

/* Turn off PD12..PD15 */
void LEDs_off(void) {
    GPIOD->BSRR = ((1U<<12) | (1U<<13) | (1U<<14) | (1U<<15)) << 16; // reset bits
}

/* Blink all 4 LEDs repeats times with on_ms and off_ms delays */
void blink_mode(uint32_t on_ms, uint32_t off_ms, uint32_t repeats) {
    for(uint32_t i=0; i<repeats; ++i) {
        LEDs_on();
        delay_ms(on_ms);
        LEDs_off();
        delay_ms(off_ms);
    }
}

/* Initialize GPIOD pins 12..15 as general purpose outputs */
void GPIO_Init_PD12_15(void) {
    /* Enable GPIOD clock */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;
    /* Small delay to let clock start */
    volatile uint32_t tmp = RCC->AHB1ENR;
    (void)tmp;

    /* Set PD12..PD15 to output (MODER = 01) */
    GPIOD->MODER &= ~(
        (3U << (12*2)) |
        (3U << (13*2)) |
        (3U << (14*2)) |
        (3U << (15*2))
    );
    GPIOD->MODER |= (
        (1U << (12*2)) |
        (1U << (13*2)) |
        (1U << (14*2)) |
        (1U << (15*2))
    );

    /* Set output type push-pull (default 0) */
    GPIOD->OTYPER &= ~(
        (1U<<12) | (1U<<13) | (1U<<14) | (1U<<15)
    );
    /* Medium speed */
    GPIOD->OSPEEDR |= (
        (2U << (12*2)) |
        (2U << (13*2)) |
        (2U << (14*2)) |
        (2U << (15*2))
    );
    /* No pull-up/pull-down */
    GPIOD->PUPDR &= ~(
        (3U << (12*2)) |
        (3U << (13*2)) |
        (3U << (14*2)) |
        (3U << (15*2))
    );
}

/* TIM2 init to generate update event at 1 Hz.
   Assumes TIM2 clock = 84 MHz. Adjust PSC/ARR if your timer clock differs.
*/
void TIM2_Init_1Hz(void) {
    /* Enable TIM2 clock (APB1) */
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
    volatile uint32_t tmp = RCC->APB1ENR; (void)tmp;

    /* Disable timer while configuring */
    TIM2->CR1 = 0;

    /* PSC and ARR values for 1 Hz from 84 MHz timer clock:
       PSC = 8399 -> divides by 8400
       ARR = 9999 -> further divides by 10000
       Result: 84,000,000 / 8400 / 10000 = 1 Hz
    */
    TIM2->PSC = 8399U;
    TIM2->ARR = 9999U;

    /* Clear update flag */
    TIM2->SR = 0;

    /* Enable update interrupt */
    TIM2->DIER |= TIM_DIER_UIE;

    /* Enable TIM2 IRQ in NVIC with lower priority than EXTI0 (1) */
    NVIC_SetPriority(TIM2_IRQn, 1);
    NVIC_EnableIRQ(TIM2_IRQn);

    /* Enable timer */
    TIM2->CR1 |= TIM_CR1_CEN;
}

/* TIM2 IRQ handler: scheduler + run blink sequence inline
   Important: the scheduler should not be interrupted by EXTI0 while executing.
   To guarantee that, we disable EXTI0 IRQ at entry and re-enable at exit,
   and use led_mutex to indicate ownership of LEDs.
*/
void TIM2_IRQHandler(void) {
    /* Check update interrupt flag */
    if (TIM2->SR & TIM_SR_UIF) {
        /* Clear UIF */
        TIM2->SR &= ~TIM_SR_UIF;

        /* Acquire LED mutex and prevent EXTI0 from firing while we run */
        /* Disable EXTI0 IRQ so EXTI0 won't preempt us while we hold LEDs */
        NVIC_DisableIRQ(EXTI0_IRQn);
        led_mutex = 1; /* lock */

        /* Scheduler: select mode based on toggling sched_mode
           On first call sched_mode==0 -> slow mode (200ms on/off, 2 repeats)
           On second call sched_mode==1 -> fast mode (100ms on/off, 2 repeats)
        */
        if (sched_mode == 0) {
            /* Slow mode: two blinks with 200ms on / 200ms off each */
            blink_mode(200, 200, 2);
            sched_mode = 1; /* next time: fast */
        } else {
            /* Fast mode: two blinks with 100ms on / 100ms off each */
            blink_mode(100, 100, 2);
            sched_mode = 0; /* next time: slow */
        }

        /* Release LED mutex and re-enable EXTI0 */
        led_mutex = 0; /* unlock */
        NVIC_EnableIRQ(EXTI0_IRQn);
    }
}

/* EXTI0 (PA0) initialization for user button
   - Configure PA0 as input (default)
   - Configure SYSCFG exti line 0 -> PA0
   - Configure rising edge trigger (button press when goes high)
   - Mask/unmask IMR
   - Set NVIC priority to 0 (highest) and enable EXTI0_IRQn
*/
void EXTI0_Init_PA0(void) {
    /* Enable GPIOA clock (PA0 pin) */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    volatile uint32_t tmp = RCC->AHB1ENR; (void)tmp;

    /* Ensure SYSCFG clock enabled to route PA0 to EXTI0 */
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
    tmp = RCC->APB2ENR; (void)tmp;

    /* Select PA0 for EXTI0 - SYSCFG_EXTICR1[3:0] = 0 for PA[x] */
    SYSCFG->EXTICR[0] &= ~(0xF << 0); /* already 0 but ensure cleared */

    /* Configure EXTI0 trigger on rising edge */
    EXTI->RTSR |= (1U << 0);
    EXTI->FTSR &= ~(1U << 0);

    /* Unmask EXTI0 (IMR) */
    EXTI->IMR |= (1U << 0);

    /* Clear any pending EXTI0 */
    EXTI->PR = (1U << 0);

    /* Configure NVIC: priority 0 (highest) for EXTI0 IRQ */
    NVIC_SetPriority(EXTI0_IRQn, 0);
    NVIC_EnableIRQ(EXTI0_IRQn);
}

/* EXTI0 IRQ handler - toggles emergency_mode when permitted
   - If we can acquire the LED mutex (led_mutex == 0), toggle emergency_mode.
   - When enabling emergency_mode: disable TIM2 IRQ and lock LED mutex.
   - When disabling emergency_mode: re-enable TIM2 IRQ and release LED mutex.
   Note: EXTI0 has higher NVIC priority than TIM2, but TIM2 disables EXTI0
         during its critical section so EXTI0 will not preempt TIM2.
*/
void EXTI0_IRQHandler(void) {
    /* Check pending flag for line 0 */
    if (EXTI->PR & (1U << 0)) {
        /* Clear pending bit by writing 1 */
        EXTI->PR = (1U << 0);

        /* If scheduler currently holds the mutex, do nothing (ignore) */
        /* This situation should be rare because TIM2 disabled EXTI0 during its run.
           But checking led_mutex provides extra safety. */
        if (led_mutex) {
            /* Optionally record that button was pressed during scheduler.
               For now, ignore the press (it will have no effect). */
            return;
        }

        /* Toggle emergency mode */
        if (emergency_mode == 0) {
            /* Enter emergency mode:
               - Lock LEDs (so TIM2 won't try to use them)
               - Disable TIM2 IRQ to stop scheduler while emergency active
               - Set emergency_mode flag; main loop will perform blinking
            */
            led_mutex = 1;
            NVIC_DisableIRQ(TIM2_IRQn);
            emergency_mode = 1;
        } else {
            /* Exit emergency mode:
               - Clear emergency flag
               - Re-enable TIM2 IRQ
               - Release LED mutex
            */
            emergency_mode = 0;
            NVIC_EnableIRQ(TIM2_IRQn);
            led_mutex = 0;
        }
    }
}

/* Initialize SysTick for 1 ms ticks based on SystemCoreClock */
void SysTick_Init_1ms(void) {
    /* SysTick_Config uses SystemCoreClock CMSIS variable.
       It sets reload = SystemCoreClock/1000 - 1 to get 1ms tick.
    */
    if (SysTick_Config(SystemCoreClock / 1000U) != 0) {
        /* Handle error - infinite loop */
        while (1) { __NOP(); }
    }
    /* Optionally set SysTick IRQ priority */
    NVIC_SetPriority(SysTick_IRQn, 2);
}

/* main */
int main(void) {
    /* SystemInit() is called before main in startup (sets up clocks and SystemCoreClock).
       If your project doesn't call SystemInit(), ensure SystemCoreClock is set appropriately.
    */

    /* Initialize SysTick early for reliable ms delays */
    SysTick_Init_1ms();

    /* Initialize LEDs */
    GPIO_Init_PD12_15();
    LEDs_off();

    /* Initialize EXTI0 (user button PA0) */
    EXTI0_Init_PA0();

    /* Initialize TIM2 to 1 Hz (scheduler) */
    TIM2_Init_1Hz();

    /* Main loop: when emergency_mode is active, blink LEDs 1s on/off continuously.
       Blinking is done in main context (not inside EXTI handler).
       TIM2 IRQ is disabled while emergency_mode is active (see EXTI handler).
    */
    while (1) {
        if (emergency_mode) {
            /* We already hold LED mutex when emergency_mode==1 (set in EXTI handler) */
            LEDs_on();
            delay_ms(1000);
            LEDs_off();
            delay_ms(1000);
            /* loop repeats until EXTI toggles emergency_mode off */
        } else {
            /* Idle - wait for interrupts to occur (TIM2 scheduler or button) */
            __WFI();
        }
    }
}
